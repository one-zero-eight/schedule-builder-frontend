/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/collisions/check": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Check Timetable Collisions */
        post: operations["check_timetable_collisions_collisions_check_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/options/set-semester": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Set Semester */
        post: operations["set_semester_options_set_semester_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/options/semester": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Semester */
        get: operations["get_semester_options_semester_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/options/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get All Options */
        get: operations["get_all_options_options__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/options/set-teachers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Teachers
         * @description Upload teachers data from TSV (tab-separated values).
         *
         *     Expected columns (case-insensitive):
         *     - Name - teacher's full name in English
         *     - Russian Name (or ФИО/Имя) - teacher's full name in Russian
         *     - Alias (or Telegram) - short name or telegram handle
         *     - Email - email address
         *     - Student Group (or Student?) - student group code (e.g. "B24-CSE-05", "M25-SE-01")
         *
         *     Example:
         *     ```
         *     Name        Russian Name    Alias   Email   Student Group
         *     Ivan Ivanov Иванов Иван Иванович    @ivanov ivanov@example.com
         *     Petr Petrov Петров Петр Петрович    -       petrov@example.com      B24-CSE-05
         *     ```
         */
        post: operations["set_teachers_options_set_teachers_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/options/teachers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Teachers */
        get: operations["get_teachers_options_teachers_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dev/bookings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get All Bookings */
        get: operations["get_all_bookings_dev_bookings_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dev/bookings/{room_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Bookings */
        get: operations["get_bookings_dev_bookings__room_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/dev/rooms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Rooms */
        get: operations["get_rooms_dev_rooms_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/parser/parse-location-string": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Parse Location String Route */
        post: operations["parse_location_string_route_parser_parse_location_string_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * BookingDTO
         * @description Booking description
         */
        BookingDTO: {
            /**
             * Room Id
             * @description ID of the room
             */
            room_id: string;
            /**
             * Event Id
             * @description ID of the event
             */
            event_id: string | null;
            /**
             * Title
             * @description Title of the booking
             */
            title: string;
            /**
             * Start Time
             * Format: date-time
             * @description Start time of booking
             */
            start_time: string;
            /**
             * End Time
             * Format: date-time
             * @description End time of booking
             */
            end_time: string;
        };
        /**
         * CapacityIssue
         * @description Issue when there is not enough places in the room for the lesson.
         */
        CapacityIssue: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            collision_type: CapacityIssueCollision_type;
            /**
             * Room
             * @description Room name
             */
            room: string | string[];
            /**
             * Room Capacity
             * @description Assumed capacity of the room
             */
            room_capacity: number | null;
            /**
             * Needed Capacity
             * @description Needed capacity for the lesson (sum of all groups)
             */
            needed_capacity: number;
            lesson: components["schemas"]["Lesson"];
        };
        /** CheckParameters */
        CheckParameters: {
            /**
             * Care About Core Courses
             * @default true
             */
            care_about_core_courses: boolean;
            /**
             * Care About Electives
             * @default true
             */
            care_about_electives: boolean;
            /**
             * Check Room Collisions
             * @default true
             */
            check_room_collisions: boolean;
            /**
             * Check Teacher Collisions
             * @default true
             */
            check_teacher_collisions: boolean;
            /**
             * Check Space Collisions
             * @default true
             */
            check_space_collisions: boolean;
            /**
             * Check Outlook Collisions
             * @default true
             */
            check_outlook_collisions: boolean;
        };
        /** CheckResults */
        CheckResults: {
            /** Issues */
            issues: components["schemas"]["Issue"][];
        };
        /**
         * Elective
         * @description How it will be in innohassle event group name: spring26-bs2-ru-ввтус
         *     - semester alias: spring26
         *     - sheet name: bs2-ru
         *     - elective alias: ввтус
         */
        Elective: {
            /** Alias */
            alias: string;
            /** Short Name */
            short_name: string;
            /** Name */
            name?: string | null;
            /** Instructor */
            instructor?: string | null;
            /** Elective Type */
            elective_type?: string | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        Issue: components["schemas"]["CapacityIssue"] | components["schemas"]["RoomIssue"] | components["schemas"]["OutlookIssue"] | components["schemas"]["TeacherIssue"];
        /**
         * Item
         * @description Represents a parsed location string with optional modifiers and nested locations.
         *
         *     This class is the result of parsing location strings from spreadsheet cells (third row
         *     in CoreCourseCell). The location string can contain room numbers, online indicators,
         *     and various temporal modifiers that affect when and where events occur.
         *
         *     ## Flow Overview
         *
         *     ### 1. Input: Spreadsheet Location String
         *     Location strings come from the third cell value in CoreCourseCell (value[2]).
         *     Examples:
         *     - "313" → simple room number
         *     - "ONLINE" → online event
         *     - "313 (WEEK 1-3) / ONLINE" → room 313 for weeks 1-3, then online
         *     - "ONLINE ON 13/09, 108 ON 01/11 (STARTS AT 9:00)" → online on 13/09, room 108 on 01/11, both starting at 9:00
         *     - "460 EXCEPT 28/11" → room 460, excluding 28/11
         *
         *     ### 2. Parsing: parse_location_string()
         *     The location string is normalized (uppercased, "AND" replaced with commas) and parsed
         *     into an Item object. The parser recognizes:
         *
         *     **Locations:**
         *     - Room numbers: "313", "room 107", "ROOM #107" → location="313" or "107"
         *     - Online: "ONLINE", "ОНЛАЙН", "ONLINE (TBA)" → location="ONLINE" or "ОНЛАЙН"
         *     - Unknown: "?" → location="?"
         *     - Multiple: "106/313/314" → location="106/313/314"
         *
         *     **Modifiers:**
         *     - `starts_from`: "STARTS FROM 21/09" → starts_from=date(2024, 9, 21)
         *     - `starts_at`: "STARTS AT 18:00" → starts_at=time(18, 0)
         *     - `till`: "TILL 21:00" → till=time(21, 0)
         *     - `on_weeks`: "WEEK 1-3" → on_weeks=[1, 2, 3]
         *     - `on`: "ON 13/09, 20/09" → on=[date(2024, 9, 13), date(2024, 9, 20)]
         *     - `except_`: "EXCEPT 30/01, 06/02" → except_=[date(2024, 1, 30), date(2024, 2, 6)]
         *
         *     **Nested Structures (NEST):**
         *     Complex patterns create nested Items:
         *     - "313 (WEEK 1-3) / ONLINE" → Item(location="313", on_weeks=[1,2,3], NEST=[Item(location="ONLINE")])
         *     - "105 ON 15/10, 106 ON 29/10" → Item(location="105", on=[...], NEST=[Item(location="106", on=[...])])
         *     - "ONLINE ON 13/09, 108 ON 01/11 (STARTS AT 9:00)" → Item with nested items sharing starts_at
         *
         *     ### 3. Output: ICS Calendar Events (generate_vevents())
         *     The Item is converted to one or more ICS calendar events:
         *
         *     **Simple Case (no location_item):**
         *     - Creates one recurring event with RRULE (weekly recurrence)
         *     - Uses event.location, event.start_time, event.end_time
         *
         *     **With location_item:**
         *
         *     **Base Event Properties:**
         *     - `location`: Uses location_item.location or falls back to event.location
         *     - `starts`: Uses location_item.starts_from or falls back to event.starts
         *     - `start_time`: Adjusted if location_item.starts_at exists (keeps duration)
         *     - `end_time`: Set to location_item.till if exists, otherwise calculated from start_time + duration
         *
         *     **Recurrence Handling:**
         *     - `on_weeks` → Converted to specific dates using nearest_weekday() + weeks offset, merged into `on`
         *     - If `on` exists: Creates events with RDATE (specific dates) instead of RRULE
         *       - Each date in `on` becomes a recurrence date
         *       - dtstart/dtend adapted to first date in `on`
         *     - If `on` is None: Creates weekly recurring event with RRULE
         *     - If `except_` exists: Adds EXDATE to exclude specific dates from recurrence
         *
         *     **Nested Items (NEST):**
         *     Nested items create additional calendar events:
         *
         *     - If parent has RRULE (weekly recurrence):
         *       - For each nested item with `on` dates:
         *         - Creates RECURRENCE-ID events overriding specific recurrence instances
         *         - Uses nested item's location, starts_at, till if specified
         *         - Removes RRULE from override event
         *         - Parent event still yields with RRULE
         *
         *     - If parent has RDATE (specific dates):
         *       - Creates separate events for nested items
         *       - Each nested item gets its own RDATE with its `on` dates
         *       - Uses nested item's location, starts_at, till if specified
         *       - Parent event yields first, then nested events
         *
         *     **Examples of ICS Output:**
         *
         *     Input: "313"
         *     → One event: location="313", RRULE=FREQ=WEEKLY
         *
         *     Input: "ONLINE ON 13/09, 20/09"
         *     → One event: location="ONLINE", RDATE=[2024-09-13, 2024-09-20]
         *
         *     Input: "313 (WEEK 1-3) / ONLINE"
         *     → Two events:
         *       1. location="313", RRULE=FREQ=WEEKLY (with EXDATE for weeks after 3)
         *       2. location="ONLINE", RDATE=[dates for weeks 4+]
         *
         *     Input: "ONLINE ON 13/09, 108 ON 01/11 (STARTS AT 9:00)"
         *     → Three events:
         *       1. location="ONLINE", RDATE=[2024-09-13], dtstart=09:00
         *       2. location="108", RDATE=[2024-11-01], dtstart=09:00
         *       3. Parent recurring event (if applicable)
         *
         *     Input: "460 EXCEPT 28/11"
         *     → One event: location="460", RRULE=FREQ=WEEKLY, EXDATE=[2024-11-28]
         */
        Item: {
            /**
             * Location
             * @description Room number, "ONLINE", "ОНЛАЙН", "?", or slash-separated combinations like "106/313"
             */
            location?: string | null;
            /**
             * Starts From
             * @description Date when the event starts (overrides event.starts)
             */
            starts_from?: string | null;
            /**
             * Starts At
             * @description Time when the event starts (overrides event.start_time, preserves duration)
             */
            starts_at?: string | null;
            /**
             * Till
             * @description Time when the event ends (overrides event.end_time)
             */
            till?: string | null;
            /**
             * On Weeks
             * @description List of week numbers (1-based, converted to dates during ICS generation)
             */
            on_weeks?: number[] | null;
            /**
             * On
             * @description List of specific dates when event occurs (creates RDATE instead of RRULE)
             */
            on?: string[] | null;
            /**
             * Except
             * @description List of dates to exclude from recurrence (creates EXDATE)
             */
            except_?: string[] | null;
            /**
             * Nest
             * @description List of nested Item objects for complex location patterns
             */
            NEST?: components["schemas"]["Item"][] | null;
        };
        /** Lesson */
        Lesson: {
            /**
             * Lesson Name
             * @description Name of the lesson
             */
            lesson_name: string;
            /**
             * Weekday
             * @description Weekday of a lesson
             */
            weekday: string | null;
            /**
             * Start Time
             * Format: time
             * @description Start time of lesson
             */
            start_time: string;
            /**
             * End Time
             * Format: time
             * @description End time of lesson
             */
            end_time: string;
            /**
             * Room
             * @description Room for lesson, None - TBA, if list - multiple rooms simultaneously
             */
            room: string | string[] | null;
            /**
             * Teacher
             * @description Teacher on lesson
             */
            teacher: string | null;
            /**
             * Course Name
             * @description Name of the course
             */
            course_name: string | null;
            /**
             * Group Name
             * @description Name of the group or list of groups
             */
            group_name: string | string[] | null;
            /**
             * Students Number
             * @description Number of students in the group
             */
            students_number: number | null;
            /**
             * Date On
             * @description Specific dates with lessons
             */
            date_on: string[] | null;
            /**
             * Date Except
             * @description Specific dates when there is no lessons
             */
            date_except: string[] | null;
            /**
             * Date From
             * @description Date from which the lesson starts
             */
            date_from: string | null;
            /**
             * Spreadsheet Id
             * @description Spreadsheet ID
             */
            spreadsheet_id: string;
            /**
             * Google Sheet Gid
             * @description Google Spreadsheet ID of the sheet
             */
            google_sheet_gid: string;
            /**
             * Google Sheet Name
             * @description Sheet name to which the lesson belongs in Google Spreadsheet
             */
            google_sheet_name: string;
            /**
             * A1 Range
             * @description Range of the lesson: may be multiple cells, for example 'A1:A10'
             */
            a1_range: string | null;
        };
        /** OptionsData */
        OptionsData: {
            semester: components["schemas"]["SemesterOptions-Output"] | null;
            teachers: components["schemas"]["TeachersData"] | null;
        };
        /**
         * OutlookIssue
         * @description Issue when there is a Outlook booking in the room at the same time as the lesson. Grouped by Outlook event title.
         */
        OutlookIssue: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            collision_type: OutlookIssueCollision_type;
            /**
             * Outlook Event Title
             * @description Title of the Outlook event
             */
            outlook_event_title: string;
            /**
             * Outlook Info
             * @description Outlook info about the bookings in the same time
             */
            outlook_info: components["schemas"]["BookingDTO"][];
            /**
             * Lessons
             * @description Lessons that are in conflict with the Outlook event
             */
            lessons: components["schemas"]["Lesson"][];
        };
        /** Override */
        Override: {
            /** Groups */
            groups: string[];
            /** Courses */
            courses: string[];
            /**
             * Start Date
             * Format: date-time
             */
            start_date: string;
            /**
             * End Date
             * Format: date
             */
            end_date: string;
        };
        /** ParseLocationStringResponse */
        ParseLocationStringResponse: {
            location_item: components["schemas"]["Item"];
            /** Description */
            description: string;
        };
        /**
         * RoomDTO
         * @description Room description.
         */
        RoomDTO: {
            /**
             * Id
             * @description Room slug
             */
            id: string;
            /**
             * Title
             * @description Room title
             */
            title: string | null;
            /**
             * Short Name
             * @description Shorter version of room title
             */
            short_name: string | null;
            /**
             * My Uni Id
             * @description ID of room on My University portal
             */
            my_uni_id: number | null;
            /**
             * Capacity
             * @description Room capacity, amount of people
             */
            capacity: number | null;
            /**
             * Access Level
             * @description Access level to the room. Yellow = for students. Red = for employees. Special = special rules apply.
             */
            access_level: RoomDTOAccess_level | null;
            /**
             * Restrict Daytime
             * @description Prohibit to book during working hours. True = this room is available only at night 19:00-8:00, or full day on weekends.
             * @default false
             */
            restrict_daytime: boolean;
        };
        /**
         * RoomIssue
         * @description Issue when there are multiple lessons in the room at the same time.
         */
        RoomIssue: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            collision_type: RoomIssueCollision_type;
            /**
             * Room
             * @description Room name
             */
            room: string | string[];
            /**
             * Lessons
             * @description Lessons in the room at the same time
             */
            lessons: components["schemas"]["Lesson"][];
        };
        /** SemesterOptions */
        "SemesterOptions-Input": {
            /** Name */
            name: string;
            /** Core Courses Spreadsheet Id */
            core_courses_spreadsheet_id?: string | null;
            /**
             * Core Courses Targets
             * @default []
             */
            core_courses_targets: components["schemas"]["src__core_courses__config__Target"][];
            /** Electives Spreadsheet Id */
            electives_spreadsheet_id?: string | null;
            /**
             * Electives Targets
             * @default []
             */
            electives_targets: components["schemas"]["Target"][];
            /**
             * Electives
             * @default []
             */
            electives: components["schemas"]["Elective"][];
        };
        /** SemesterOptions */
        "SemesterOptions-Output": {
            /** Name */
            name: string;
            /** Core Courses Spreadsheet Id */
            core_courses_spreadsheet_id: string | null;
            /**
             * Core Courses Targets
             * @default []
             */
            core_courses_targets: components["schemas"]["src__core_courses__config__Target"][];
            /** Electives Spreadsheet Id */
            electives_spreadsheet_id: string | null;
            /**
             * Electives Targets
             * @default []
             */
            electives_targets: components["schemas"]["Target"][];
            /**
             * Electives
             * @default []
             */
            electives: components["schemas"]["Elective"][];
        };
        /** Target */
        Target: {
            /** Sheet Name */
            sheet_name: string;
        };
        /** Teacher */
        Teacher: {
            /** Name */
            name: string;
            /** Russian Name */
            russian_name: string | null;
            /** Email */
            email: string | null;
            /** Alias */
            alias: string | null;
            /** Student Group */
            student_group: string | null;
        };
        /**
         * TeacherIssue
         * @description Issue when there is a teacher with multiple lessons at the same time, or when teacher study in the same time as the lesson.
         */
        TeacherIssue: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            collision_type: TeacherIssueCollision_type;
            /**
             * Teacher
             * @description Teacher name
             */
            teacher: string;
            /**
             * Teaching Lessons
             * @description Lessons of the teacher at the same time
             */
            teaching_lessons: components["schemas"]["Lesson"][];
            /**
             * Studying Lessons
             * @description Lessons of the teacher as a student at the same time
             */
            studying_lessons: components["schemas"]["Lesson"][];
        };
        /** TeachersData */
        TeachersData: {
            /**
             * Data
             * @default []
             */
            data: components["schemas"]["Teacher"][];
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
            /** Input */
            input?: unknown;
            /** Context */
            ctx?: Record<string, never>;
        };
        /** Target */
        src__core_courses__config__Target: {
            /** Sheet Name */
            sheet_name: string;
            /**
             * Start Date
             * Format: date
             */
            start_date: string;
            /**
             * End Date
             * Format: date
             */
            end_date: string;
            /** Override */
            override: components["schemas"]["Override"][];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type SchemaBookingDto = components['schemas']['BookingDTO'];
export type SchemaCapacityIssue = components['schemas']['CapacityIssue'];
export type SchemaCheckParameters = components['schemas']['CheckParameters'];
export type SchemaCheckResults = components['schemas']['CheckResults'];
export type SchemaElective = components['schemas']['Elective'];
export type SchemaHttpValidationError = components['schemas']['HTTPValidationError'];
export type SchemaIssue = components['schemas']['Issue'];
export type SchemaItem = components['schemas']['Item'];
export type SchemaLesson = components['schemas']['Lesson'];
export type SchemaOptionsData = components['schemas']['OptionsData'];
export type SchemaOutlookIssue = components['schemas']['OutlookIssue'];
export type SchemaOverride = components['schemas']['Override'];
export type SchemaParseLocationStringResponse = components['schemas']['ParseLocationStringResponse'];
export type SchemaRoomDto = components['schemas']['RoomDTO'];
export type SchemaRoomIssue = components['schemas']['RoomIssue'];
export type SchemaSemesterOptionsInput = components['schemas']['SemesterOptions-Input'];
export type SchemaSemesterOptionsOutput = components['schemas']['SemesterOptions-Output'];
export type SchemaTarget = components['schemas']['Target'];
export type SchemaTeacher = components['schemas']['Teacher'];
export type SchemaTeacherIssue = components['schemas']['TeacherIssue'];
export type SchemaTeachersData = components['schemas']['TeachersData'];
export type SchemaValidationError = components['schemas']['ValidationError'];
export type SchemaSrcCoreCoursesConfigTarget = components['schemas']['src__core_courses__config__Target'];
export type $defs = Record<string, never>;
export interface operations {
    check_timetable_collisions_collisions_check_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckParameters"];
            };
        };
        responses: {
            /** @description Timetable collisions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckResults"];
                };
            };
            /** @description Invalid token OR no credentials provided */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_semester_options_set_semester_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SemesterOptions-Input"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SemesterOptions-Output"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_semester_options_semester_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SemesterOptions-Output"] | null;
                };
            };
        };
    };
    get_all_options_options__get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OptionsData"];
                };
            };
        };
    };
    set_teachers_options_set_teachers_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "text/tab-separated-values": string;
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeachersData"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_teachers_options_teachers_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TeachersData"] | null;
                };
            };
        };
    };
    get_all_bookings_dev_bookings_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingDTO"][];
                };
            };
        };
    };
    get_bookings_dev_bookings__room_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                room_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BookingDTO"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_rooms_dev_rooms_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RoomDTO"][];
                };
            };
        };
    };
    parse_location_string_route_parser_parse_location_string_post: {
        parameters: {
            query: {
                location_string: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ParseLocationStringResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
export enum CapacityIssueCollision_type {
    capacity = "capacity"
}
export enum OutlookIssueCollision_type {
    outlook = "outlook"
}
export enum RoomDTOAccess_level {
    yellow = "yellow",
    red = "red",
    special = "special"
}
export enum RoomIssueCollision_type {
    room = "room"
}
export enum TeacherIssueCollision_type {
    teacher = "teacher"
}
